#ifndef __randomwalk__
#define __randomwalk__

#include "random.h"
#include <cmath>
#include <fstream>
#include <iostream>
#include <numeric>
#include <string>
#include <vector>

using namespace std;

class randomwalk {

public:
  // Constructor that initializes the object with the given number of dimensions
  // and length of the step
  randomwalk(int dim, double lengthstep) {
    m_dim = dim;
    m_position.resize(m_dim, 0.0);
    m_lengthstep = lengthstep;

    int seed[4];
    int p1, p2;
    ifstream Primes("Primes");
    if (Primes.is_open()) {
      Primes >> p1 >> p2;
    } else
      cerr << "PROBLEM: Unable to open Primes" << endl;
    Primes.close();

    ifstream input("seed.in");
    string property;
    if (input.is_open()) {
      while (!input.eof()) {
        input >> property;
        if (property == "RANDOMSEED") {
          input >> seed[0] >> seed[1] >> seed[2] >> seed[3];
          rnd.SetRandom(seed, p1, p2);
        }
      }
      input.close();
    } else {
      cerr << "PROBLEM: Unable to open seed.in" << endl;
    }
  }

  ~randomwalk() {}

  void RWsaveseed(){
    rnd.SaveSeed();
  }

  // Resets the position of the walker to the origin
  void restart() { m_position.assign(m_dim, 0.0); }

  // Returns the square of the distance from the origin
  double distancesquared() {
    return inner_product(m_position.begin(), m_position.end(),  m_position.begin(), 0.0);
  }

  // Makes nstep discrete step by moving the walker a fixed lengthstep along a random direction
  void makediscretestep(int nstep) {
    int randomint;
    for (int i = 0; i < nstep; i++) {
      randomint = int(rnd.Rannyu() * (2 * m_dim));
      // Generates a random integer between 0 and 2*m_dim-1 and decides whether to move the walker (depending on the parity of randomint)
      // in the positive or negative direction along the corresponding axis
      if (randomint % 2 == 0) {
        m_position[randomint / 2] += m_lengthstep;
      } else {
        m_position[randomint / 2] -= m_lengthstep;
      }
    }
  }

  // Generates a random unit vector in m_dim dimensions
  vector<double> random_unit_vector() {
    vector<double> step(m_dim, 0.0);
    double norm = 0.0;
    for (int i = 0; i < m_dim; i++) {
      step[i] = rnd.Gauss(0.0, 1.0);
      norm += step[i] * step[i];
    }
    norm = sqrt(norm);
    // divide each element of the vector by the norm to obtain a unit vector.
    for (int i = 0; i < m_dim; i++) {
      step[i] /= norm;
    }
    return step;
  }

  // Makes a continuous step by moving the walker a fixed lengthstep along a random direction generated by the random_unit_vector() method
  void makecontinuousstep(int nstep) {
    vector<double> step(m_dim, 0.0);
    for (int i = 0; i < nstep; i++) {
      step = random_unit_vector();
      for (int j = 0; j < m_dim; j++) {
        m_position[j] += (m_lengthstep * step[j]);
      }
    }
  }

  // Class members
private:
  double m_lengthstep;       // Step length
  vector<double> m_position; // Current position vector
  int m_dim;                 // Dimension of the random walk
  Random rnd;                // Random number generator object
};

#endif // __randomwalk__